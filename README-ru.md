[Английская версия (English version)](https://github.com/epicoon/lx-core/README.md)

# Lx - платформа для создания вэб-приложений

В данном репозитории находится ядро платформы. Одного его уже достаточно для создания вэб-приложений, но рекомендуем ознакомиться с прочими полезными репозиториями, содержащими документацию, инструменты и примеры для данной платформы:
* [lx-doc](https://github.com/epicoon/lx-doc/README-ru.md)
* [lx-demo](https://github.com/epicoon/lx-demo/README-ru.md)
* [lx-dev-wizard](https://github.com/epicoon/lx-dev-wizard/README-ru.md)
* [lx-tools](https://github.com/epicoon/lx-tools/README-ru.md)


## Оглавление
* [Основные принципы](#properties)
* [Установка](#deploy)
* [Описание архитектуры](#architecture)
* [CLI](#cli)
* [Пример разработки приложения](https://github.com/epicoon/lx-doc-articles/ru/app-dev/expl1/main.md)
* [Список статей по документации](#doc-list)


<a name="properties"><h2>Основные принципы</h2></a>
* Платформа относится к категории фуллстак-технологий. Объединяет рабработку бэкенда и фронтенда.
* Мультисервисная архитектура. Приложение состоит из сервисов - независымых друг от друга фрагментов логики.
* Повторное использование кода. Все элементы архитектуры реиспользуемы.
* Гибко настраиваемый роутинг.
* Работа с минимумом перезагрузок страницы. Поддержка простой работы через AJAX.
* Объектно-ориентированный подход к построению графических интерфейсов.
* Простая, легко расширяемая интернационализация.


<a name="deploy"><h2>Установка</h2></a>
1. Для установки платформы воспользуйтесь менеджером php-пакетов `Composer`
   Пример файла `composer.json`:
   ```
   {
       "require":{
           "lx/lx-core":"dev-master"
       },
       "repositories":[
           {
               "type":"git",
               "url":"https://github.com/epicoon/lx-core"
           }
        ]
   }
   ```
   Чтобы использовать прочие lx-пакеты, просто добавьте их в конфигурационный файл по аналогии с пакетом `lx/lx-core`, например: [конфигурация с прочими lx-пакетами](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/composer-example.md).<br>
   В корне проекта выполните команду `composer install`.<br>
   В результате будет создан каталог `vendor` (если еще не существовал). В нем в папке `lx` будут располагаться указанные в зависимостях пакеты.
2. Настройка сервера для `nginx` под `Ubuntu`.<br>
   Конфигурация:
   ```
   server {
      charset utf-8;
      client_max_body_size 128M;
      listen 80;
      listen [::]:80;

      server_name server.name;
      root /path/to/project;
      index path/to/index.php;
  
      location / {
         try_files $uri /path/to/index.php?$args;
      }

      location ~ \.php$ {
         include fastcgi_params;
         fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
         fastcgi_pass unix:/run/php/php7.1-fpm.sock;
      }
   }
   ```
   Обратите внимание на пути и версию php-fpm, подставьте свои значения.<br>
   Создайте запись в `/etc/hosts`.<br>
   Перезапустите сервер.<br>
3. Чтобы развернуть платформу в проекте, нужно запустить PHP-скрипт `vendor/lx/lx-core/lx-install`.<br>
   В результате в корне проекта будут созданы каталоги:
   * lx - каталог для конфигурационных и системных файлов платформы. Обязателен.
   * services - каталог для сервисов приложения (подробности ниже). Содержит первый сервис для приложения. Необязателен, работа с сервисами настраивается в конфигурации приложения.
4. Осталось вызвать запуск lx-приложения.
   Для этого в индексном файле нужно добавить код:
   ```php
   /* Пример приведен для ситуации, когда индексный файл находится в корне проекта
    * Если он находится в каталоге (например web), нужно скорректировать путь
    */
   require_once __DIR__ . '/vendor/lx/lx-core/main.php';
   lx::run();
   ```
5. Если в браузере по домену, указанному в конфигурации сервера и файле `/etc/hosts`, вы видите такую страницу, то все удалось.
   ![Стартовая страница lx](https://github.com/epicoon/lx-doc-articles/ru/lx-core/images/lx-start-page.png)
   Если Вы поставили рекумендуемые пакеты, то со стартовой страницы будут доступны документация (из пакета `lx/lx-doc`), набор демонстраций (из пакета `lx/lx-demo`) и CLI в web-режиме (из пакета `lx/lx-dev-wizard`).


<a name="architecture"><h2>Описание архитектуры</h2></a>
Элементы приложения, из которых складывается архитектура:
* [Пакеты](#arch-package)
* [Сервисы](#arch-service)
* [Роутер уровня приложения](#arch-router)
* [Роутеры уровня сервисов](#arch-service-router)
* [Контроллеры](#arch-controller)
* [Действия (экшены)](#arch-action)
* [Модули](#arch-module)
* [Блоки](#arch-block)
* [Виджеты](#arch-widget)
* [Респонденты](#arch-respondent)

Из всех элементов архитектуры конфигурируются специальными файлами два: сервис и модуль. А также конфигурируется само приложение.

* <a name="arch-package"><h3>Пакеты</h3></a>
  Приложение состоит из пакетов.
  Пакет это каталог, имеющий особый конфигурационный файл. Варианты названий конфигурационного файла:
  * `composer.json`
  * `lx-config.php`
  * `lx-config.yaml`
  * `lx-config/main.php`
  * `lx-config/main.yaml`<br>
  Наличие конфигурационного файла `composer.json` означает, что каталог является composer-пакетом.<br>
  Наличие конфигурационного файла с префиксом `lx` означает, что каталог является lx-пакетом.<br>
  Пакет может быть composer-пакетом и lx-пакетом одновременно (иметь оба конфигурационных файла).<br>
  В файле lx-конфигурации рекомендуется описывать правила автозагрузки (а не в `composer.json`), т.к. платформа имеет свой автозагрузчик, не противоречащий автозагрузчику композера, но имеющий расширенные возможности.<br>
  Файл `composer.json` может быть использован для описания зависимостей.<br>
  О прочих особенностях lx-конфигурации далее.<br>
  Пакеты могут располагаться в нескольких каталогах внутри приложения. В каких именно - определяется в конфигурации приложения. [Подробнее о конфигурации приложения](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/app-config.md)

* <a name="arch-service"><h3>Сервисы</h3></a>
  Сервис это пакет, умеющий отвечать на запросы. Имеет специальное поле с настройками в lx-конфигурации. Пример конфигурации на `yaml`:
  ```yaml
  # Имя сервиса
  name: lx/lx-dev-wizard

  # Правила автозагрузки
  autoload:
    psr-4:
      lx\devWizard\: ''

  # Поле с настройками сервиса - наличие именно этого поля превращает пакет в сервис
  service:
    # Если сервис представлен собственным классом, здесь указывается его имя
    class: lx\devWizard\Service

    # Прочие настройки сервиса
    modules: module
    models: model
    ...
  ```
  Имеет определенную инфраструктуру, описываемую с помощью lx-конфигурации.
  [Подробнее о конфигурации сервиса](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/service-config.md)

* <a name="arch-router"><h3>Роутер уровня приложения</h3></a>
  Приложение распределяет запросы по сервисам с помощью роутера. Он существует в приложении в единственном числе.<br>
  Настраивается роутер в конфигурации приложения. Пример:
  ```yaml
  ...
  # Варианты типов:
  # - map 
  #   необходим параметр 'routes' - сама карта, либо 'path' - где лежит карта
  #   карта - массив, где ключ - URL запроса (или регулярное выражение, если начинается с символа '~'),
  #   значение - данные от объекте, куда перенаправляется запрос
  # - class 
  #   необходим параметр 'name' - имя класса роутера, отнаследованного от [[lx\Router]]
  router:
    type: map
    routes:
      # Домашняя страница
      /: your/home-service
      # URL, ориентированный непосредственно на модуль сервиса,
      # причем работающий только для определенного режима приложения
      test-page: {service-module: 'your/some-service:some-module', on-mode: dev}
  ...
  ```
  ![Схема роутинга приложения](https://github.com/epicoon/lx-doc-articles/ru/lx-core/images/architecture-scheme.png)
  [Подробнее о роутинге](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/routing.md)

* <a name="arch-service-router"><h3>Роутеры уровня сервиса</h3></a>
  Управлением запросами внутри сервисов занимаются роутеры сервисов.<br>
  По аналогии с роутером приложения, роутер сервиса можно настройить с помощью файла lx-конфигурации сервиса, либо переопределить класс `lx\ServiceRouter`.<br>
  Пример настройки через файл lx-конфигурации:
  ```yaml
  name: some-vendor/some-service
  ...

  service:
    # Настройки роутера сервиса
    router:
      type: map
      routes:
        # Направление запроса на контроллер
        # Будет возвращен результат вызова метода контроллера [[run()]]
        some-route-1: ControllerClassName

        # Направление запроса на контроллер
        # Будет возвращен результат вызова метода(экшена) контроллера [[actionName()]]
        some-route-2: ControllerClassName::actionName

        # Направление запроса на экшен. Будет возвращен результат вызова метода экшена [[run()]]
        some-route-3: {action: ActionClassName}

        # Направление запроса на модуль. Будет возвращен результат рендеринга модуля
        some-route-4: {module: moduleName}
    ...
  ```
  ![Схема внутрисервисного роутинга](https://github.com/epicoon/lx-doc-articles/ru/lx-core/images/service-routing.png)

* <a name="arch-controller"><h3>Контроллеры</h3></a>
  Контроллер является таким элементом сервиса, который отвечает на запросы и может обрабатывать много разных URL.<br>
  Если в настройках роутера уровня сервиса для определенного URL указано только имя класса контроллера, для обработки запроса будет вызван метод `run()`.<br>
  Если в настройках роутера уровня сервиса для определенного URL указано имя класса контроллера и метод (н-р так: `ControllerClassName::actionName`), то для обработки запроса будет вызван указанный метод.

* <a name="arch-action"><h3>Действия (экшены)</h3></a>
  Действие (экшен) является таким элементом сервиса, который отвечает на какой-то один запрос.<br>
  Для обработки запроса будет вызван метод `run()`.

* <a name="arch-module"><h3>Модули</h3></a>
  Модуль является элементом сервиса, представляющим собой совокупность логики, выполняющейся на клиенте и графического интерфейса, ее обслуживающего. По своей идее напоминает SPA.
  
  Свойства модуля:
  * рендерится и загружается браузером однократно
  * выполняется без перезагрузки страницы
  * в структуре проекта имеет свою директорию с определенной инфраструктурой
  * имеет свой файл lx-конфигурации для настройки некоторых параметров и инфраструктуры
  * имеет свои ресурсы (JS-код, CSS-код, изображения и т.п.)
  * в JS-коде экземпляр самого модуля доступен в виде контекстной переменной `Module`
  * данные с сервера запрашивает при помощи ajax-запросов
  * для формирования данных, отдаваемых сервером имеет свои инструменты (респонденты)
  * любой модуль может загрузить любой другой модуль и поместить его в элемент на своей странице
  * рендеринг модуля можно инициировать с передачей параметров, в случае, если они предусмотрены
  
  Перечень элементов инфраструктуры модуля:
  * Js-код модуля. Для него предусмотрена отдельная директория (ключ конфигурации `frontend`). Корневых файлов для исполнения два - один будет выполняться до разворачивания модуля (ключ конфигурации `jsMain`), другой после (ключ конфигурации `jsBootstrap`).
  * Респонденты. Классы, которые пишутся на php, представляют собой ajax-контроллеры, отдающие данные клиентской части модуля (ключ конфигурации `respondents`).
  * Представление. Для него предусмотрена отдельная директория (ключ конфигурации `view`). Рендеринг модуля начинается с корневого блока, код которого описывается в корневом файле представления (ключ конфигурации `viewIndex`).
  * Изображения (ключ конфигурации `images`). Можно задать каталог, в котором будут лежать изображения модуля.
  * Css-ресурсы (ключ конфигурации `css`). Можно задать каталог, в котором будут лежать css-файлы модуля. При загрузке модуля эти файлы будут использоваться автоматически.<br>
  Пример настройки элементов инфраструктуры модуля в lx-конфигурации:
  ```yaml
  # В корне модуля каталог 'frontend' будет содержать js-код
  frontend: frontend
  # В каталоге 'frontend' js-код, который выполнится до разворачивания модуля,
  # будет находиться в файле '_bootstrap.js'
  jsBootstrap: _bootstrap.js
  # В каталоге 'frontend' js-код, который выполнится после разворачивания модуля,
  # будет находиться в файле '_main.js'
  jsMain: _main.js

  # Карта респондентов
  respondents:
    # Ключ - псевдоним респондента для клиентской стороны
    # Значение - имя класса респондента
    # (!)пространство имен указывается относительно пространства имен модуля
    Respondent: backend\Respondent

  # В корне модуля каталог 'view' будет содержать код графического интерфейса
  view: view
  # В каталоге 'view' корневым файлом графического интерфейса будет '_root.php',
  # он содержит код корневого блока модуля
  viewIndex: _root.php

  # Путь к директории с изображениями
  # Можно использовать алиасы приложения - тогда путь будет построен согласно алиасу
  # Можно начать с символа '/' - тогда путь будет считаться относительно корня сайта
  images: assets/images

  # Путь к директории с css-файлами
  css: assets/css
  ```
  [Подробнее о конфигурации модуля](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/module-config.md)

  Нижнее подчеркивание в названиях файлов - выбор автора платформы для обозначения особого статуса файлов (корневые файлы, точки входа для выполнения и т.п.), а также упрощения их визуального поиска в проводнике проекта при сортировке каталогов и файлов по алфавиту (нижнее подчеркивание находится между прописными и строчными символами). При желании все соглашения о путях меняются с помощью конфигурации.

* <a name="arch-block"><h3>Блоки</h3></a>
  Блоки это обособленные фрагменты графического интерфейса. Код блоков пишется в процедурном стиле (в противовес виджетам, код которых пишется в стиле ООП, см. ниже). Могут быть представлены либо отдельным php-файлом, либо каталогом, в котором должен присутствовать php-файл с представлением (в таком случае, имя php-файла должно соответствовать имени каталога блока, при этом возможно, но не обязательно предварение имени файла нижним подчеркиванием).<br>
  Примеры путей к файлам блоков:
  * path/to/block/blockName.php
  * path/to/block/blockName/blockName.php
  * path/to/block/blockName/_blockName.php
  Таким образом, философия блоков подразумевает их использование в ситуациях, когда для фрагмента интерфейса не нужно применение ОО-приемов (инкапсуляция, наследование, полиморфизм), т.е. это часть интерфейса специфичная для данного участка приложения (опять же в противовес виджетам). Однако это не означает, что отсутствует механизм повторного использования кода блоков.

  Блок может иметь свой js-код, управляющий описываемым фрагментом графического интерфейса (как раз для этого нужен вариант блока-каталога). В этом случае главный исполняемый js-файл должен иметь такое же имя, как файл представления блока (но с расширением `.js` вместо `.php`).<br>
  Пример:
  * path/to/block/blockName/blockName.php
  * path/to/block/blockName/blockName.js
  или:
  * path/to/block/blockName/_blockName.php
  * path/to/block/blockName/_blockName.js

  При написании кода блока доступны две контекстные переменные:
  * $Module - объект модуля, к которому относится блок
  * $Block - объект самого блока, с которым можно работать как с обычным виджетом класса `lx\Box`

  Блоки строятся из виджетов. Блоки могут включать в себя другие блоки посредством вызова рендеринга в коде. Пример:
  ```php
  // Создим виджет
  $menu = new lx\Box($menuConfig);

  // Виджет добавляется внутрь другого виджета
  $button = $menu->add(lx\Button::class, $buttonConfig);

  // Добавим пару виджетов, чтобы вложить в них блоки
  $box1 = new lx\Box($config1);
  $box2 = new lx\Box($config2);

  // Вкладываем блок - в данном случае имя это путь относительно файла описываемого в данный момент блока
  // Можно использовать алиасы приложения
  // Если путь начать с '/', то он считается относительно корня сайта
  $box1->setBlock('blockName1');

  // Вкладываем еще один блок - указываем конфигурацию
  // @param path - тот же путь, что в предыдущем случае
  // @param renderParams - массив параметров, которые будут доступны в качестве переменных в файле,
  //                       описывающем вкладываемый блок
  // @param clientParams - массив параметров, которые будут доступны в js-коде блока на стороне клиента
  $box2->setBlock([
    'path' => 'blockName2',
    'renderParams' => [],
    'clientParams' => [],
  ]);

  // Добавление блока: $blockName - имя блока, $config - конфигурация виджета, в который срендерится блок
  $Block->addBlock($blockName, $config);

  // Добавление нескольких блоков
  $Block->addBlocks([
    $blockName1 => $config,
    $blockName2 => $config,
  ]);

  // Добавление нескольких блоков-попапов - они будут срендерены в виджет lx\ActiveBox и изначально скрыты
  $Block->addPopups([
    $popupName1 => $config,
    $popupName2 => $config,
  ]);

  // Очень просто написать метод для сервиса, который будет рендерить часто используемые блоки:
  // Получаем сервис, имеющий метод рендеринга содержащихся в нем блоков
  $tools = \lx::getService('lx/lx-tools');
  // Рендерим пару блоков в текущий блок
  $tools->renderBlock('inputPopup');
  $tools->renderBlock('confirmPopup');
  ```

  При выполнении js-кода блока в браузере, доступно пространство имен родительского блока, но недоступно пространство имен вложенных блоков. Например, в блок `A` вложен блок `B`, в блок `B` вложен блок `C`: `A -> B -> C`. В блоках объявлены соответственно переменные `a`, `b` и `c`. Тогда в блоке `A` будет доступна только переменная `a`. В блоке `B` будут доступны переменные `a` и `b`. В блоке `C` будут доступны переменные `a`, `b` и `c`.

  Корневой блок модуля находится в его каталоге представления. Имена каталога представления и файла корневого блока задаются в lx-конфигурации модуля.

* <a name="arch-widget"><h3>Виджеты</h3></a>
  Виджеты это узкофункциональные фрагменты графического интерфейса. Код виджетов пишется в стиле ООП (в противовес блокам).<br>
  Механизм работы виджетов имеет существенные особенности:
  * Экземпляр виджета можно создать как на серверной стороне, так и на клиентской
  * Экземпляр виджета, созданный на серверной стороне, инициирует создание экземпляра на клиентской стороне
  * Код виджета представлен двумя классами - один на стороне сервера (пишется на PHP), второй на стороне клиента (пишется на JS)
  * PHP и JS классы виджета должны находиться в отдельных файлах, в общем каталоге, пример:
    * path/to/widget/MyWidget/MyWidget.php
    * path/to/widget/MyWidget/MyWidget.js
    или:
    * path/to/widget/MyWidget/_MyWidget.php
    * path/to/widget/MyWidget/_MyWidget.js
    Имя класса такого виджета должно соответствовать имени каталога 'MyWidget'.
    Код на PHP:
    ```php
    <?php

    namespace nmsp\example;

    use lx\Box;

    class MyWidget extends Box
    {
      // ... код
    }
    ```
    Код на JS:
    ```js
    class MyWidget extends lx.Box #lx:namespace nmsp.example
    {
      // ... код
    }
    ```
  * Конструктор виджета принимает конфигурацию в виде ассоциативного массива. Для легкого поиска на стороне клиента виджета, созданного на серверной стороне, важным параметром конфигурации является `key`.
  * Экземпляр виджета на стороне сервера поддерживает создание динамических свойств в стиле JS. Эти свойства будут доступны у экземпляра на стороне клиента.
  Пример:
  Код PHP:
  ```php
  // Создаем виждет с ключом
  $button = new lx\Button(['key' => 'myButton']);

  // Добавим динамическое свойство
  $button->testField = 'some text';
  ```
  Код JS:
  ```js
  // Получаем экземпляр виджета lx.Button по ключу
  // Оператор "->>" означает поиск виджета по ключу на любом уровне вложенности дерева виджетов
  const myButton = Module->>myButton;

  // Проверим динамическое свойство, в консоли увидим 'some text'
  console.log(myButton.testField);
  ```
  Таким образом, философия виджетов подразумевает использование их для описания наиболее часто используемых, узкофункциональных и универсаных фрагментов графического интерфейса. Можно провести аналогию - если блоки это здания, то виджеты - кирпичи.

* <a name="arch-respondent"><h3>Респонденты</h3></a>
  Респонденты это функциональные элементы модуля. Фактически являются php классами. Представляют собой ajax-контроллеры, которые отдают данные клиентской части модуля.
  Пример респондента:
  * Определение в конфигурации модуля
    ```yaml
    respondents:
      Respondent: backend\Respondent
    ```
  * Код респондента (согласно приведенной конфигурации должен находиться в файле `backend/Respondent.php` относительно корня модуля)
    ```php
    <?php

    namespace path\to\module\backend;

    class Respondent extends \lx\Respondent
    {
      public function test()
      {
        return 'Hello from server';
      }
    }
    ```
  * Использование респондента в js-коде модуля
    ```js
    ^Respondent.test() : (result) => {
      // result содержит строку 'Hello from server'
      console.log(result);
    };
    ```


<a name="cli"><h2>CLI</h2></a>
Приложение поддерживает интерфейс командной строки.<br>
Чтобы его запустить нужно перейти в директорию `path\to\project\lx` и выполнить команду `php lx cli`.<br>
Команда `\h` (или `help`) отобразит список доступных команд.

Создадим свой сервис. Для этого введем команду `\cs` (или `create-service`).<br>
Нам предложат ввести имя сервиса. Введем что-то вроде `i-am-vendor/my-service`.<br>
Так как в конфигурации приложения указано несколько директорий для пакетов (и сервисов в частности), нам предложат выбрать нужную директорию. Выберем вторую (services) - вводим `2`.<br>
Готово!<br>
По указанному адресу можно проверить что именно создалось, сверить с описанной в этой документации инфраструктурой сервиса.

Теперь создадим в сервисе модуль. Для этого перейдем в сервис. Сделать это можно несколькими путями, например введем команду `\g i-am-vendor/my-service` (если назвали сервис по-своему - используйте свое название). Признаком того, что мы перешли в сервис является смена `lx-cli<app>` на `lx-cli<service:i-am-vendor/my-service>`. Другой способ попасть в сервис - по индексу. Узнать индекс можно командой `\sl` - будет отображен список имеющихся сервисов, порядковый номер сервиса и есть его индекс. Например, если индекс 2, то перейти к сервису можно командой `\g -i=2`.<br>
Наконец создаем модуль командой `\cm`. Нас снова попросят ввести имя, вводим, например, `myModule`.<br>
Это все!<br>
Модуль создан, по указанному адресу можно проверить что именно создалось, сверить с описанной в этой документации инфраструктурой модуля.

Также полезная команда `\amr` (или `autoload-map-reset`). В случае добавления сервисов вручную, или изменения правил автозагрузки в конфигурациях сервисов, эта команда обновляет карту автозагрузки PHP-классов.


<a name="doc-list"><h2>Список статей по документации</h2></a>
* [Пример содержимого файла composer.json](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/composer-example.md)
* [Роутинг](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/routing.md)
* [Конфигурация приложения](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/app-config.md)
* [Конфигурация сервиса](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/service-config.md)
* [Конфигурация модуля](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/module-config.md)
* [Интернационализация](https://github.com/epicoon/lx-doc-articles/ru/lx-core/doc/i18n.md)
* [Пример создания приложения](https://github.com/epicoon/lx-doc-articles/ru/app-dev/expl1/main.md)
