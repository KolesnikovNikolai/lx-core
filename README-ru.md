[English version (Английская версия)](https://github.com/epicoon/lx-core/blob/master/README.md)

# Lx - платформа для разработки web-приложений

В данном репозитории находится ядро платформы. Одного его уже достаточно для создания вэб-приложений, но рекомендуем ознакомиться с прочими полезными репозиториями, содержащими документацию, инструменты и примеры для данной платформы:
* [lx-doc](https://github.com/epicoon/lx-doc/blob/master/README-ru.md)
* [lx-demo](https://github.com/epicoon/lx-demo/blob/master/README-ru.md)
* [lx-dev-wizard](https://github.com/epicoon/lx-dev-wizard/blob/master/README-ru.md)
* [lx-tools](https://github.com/epicoon/lx-tools/blob/master/README-ru.md)


## Оглавление
* [Основные принципы](#properties)
* [Установка](#deploy)
* [Описание архитектуры](#architecture)
* [CLI](#cli)
* [Пример разработки приложения](https://github.com/epicoon/lx-doc-articles/blob/master/ru/app-dev/expl1/main.md)


<a name="properties"><h2>Основные принципы</h2></a>
* Платформа относится к категории фуллстак-технологий. Объединяет рабработку бэкенда и фронтенда.
* Мультисервисная архитектура. Приложение состоит из сервисов - независымых друг от друга фрагментов логики.
* Повторное использование кода. Все элементы архитектуры реиспользуемы.
* Гибко настраиваемый роутинг.
* Работа с минимумом перезагрузок страницы. Поддержка простой работы через AJAX.
* Объектно-ориентированный подход к построению графических интерфейсов.
* Простая, легко расширяемая интернационализация.


<a name="deploy"><h2>Установка</h2></a>
1. Для установки платформы воспользуйтесь менеджером php-пакетов `Composer`.<br>
   Пример файла `composer.json`:
   ```
   {
       "require":{
           "lx/lx-core":"dev-master"
       },
       "repositories":[
           {
               "type":"git",
               "url":"https://github.com/epicoon/lx-core"
           }
        ],
        "scripts": {
           "post-update-cmd": [
               "php vendor/lx/lx-core/lx-install"
           ]
        }
   }
   ```
   Чтобы использовать прочие lx-пакеты, просто добавьте их в конфигурационный файл по аналогии с пакетом `lx/lx-core`, например: [конфигурация с прочими lx-пакетами](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/composer-example.md).<br>
   В корне проекта выполните команду `composer install`.<br>
   В результате будет создан каталог `vendor` (если еще не существовал). В нем в папке `lx` будут располагаться указанные в зависимостях пакеты.
   Обратите внимание на раздел "scripts". Вызывается скрипт, который в корне приложения создаст папку `lx`, необходимую для функционирования платформы. Внутри будут конфигурационные файлы, файл запуска CLI, каталоги для системных и временных файлов.Также этот скрипт создаст (или изменит) файл `.gitignore`, чтобы системные файлы платформы не отслеживались системой контроля версий.
2. Настройка сервера для `nginx` под `Ubuntu`.<br>
   Конфигурация:
   ```
   server {
      charset utf-8;
      client_max_body_size 128M;
      listen 80;
      listen [::]:80;

      server_name server.name;
      root /path/to/project;
      index path/to/index.php;
  
      location / {
         try_files $uri /path/to/index.php?$args;
      }

      location ~ \.php$ {
         include fastcgi_params;
         fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
         fastcgi_pass unix:/run/php/php7.1-fpm.sock;
      }
   }
   ```
   Обратите внимание на пути и версию php-fpm, подставьте свои значения.<br>
   Создайте запись в `/etc/hosts`.<br>
   Перезапустите сервер.<br>
3. Осталось вызвать запуск lx-приложения.
   Для этого в индексном файле нужно добавить код:
   ```php
   /* Пример приведен для ситуации, когда индексный файл находится в корне проекта
    * Если он находится в каталоге (например web), нужно скорректировать путь
    */
   require_once __DIR__ . '/vendor/lx/lx-core/main.php';
   $app = new lx\Application();
   $app->run();
   ```
4. Если в браузере по домену, указанному в конфигурации сервера и файле `/etc/hosts`, вы видите страницу:
   ![Стартовая страница lx](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/images/lx-start-page.png)
   то все удалось.


<a name="architecture"><h2>Описание архитектуры</h2></a>
Элементы приложения, из которых складывается архитектура:
* [Пакеты](#arch-package)
* [Сервисы](#arch-service)
* [Роутер уровня приложения](#arch-router)
* [Роутеры уровня сервисов](#arch-service-router)
* [Контроллеры](#arch-controller)
* [Действия (экшены)](#arch-action)
* [Плагины](#arch-plugin)
* [Сниппеты](#arch-snippet)
* [Виджеты](#arch-widget)
* [Респонденты](#arch-respondent)

Из всех элементов архитектуры конфигурируются специальными файлами два: сервис и плагин. А также конфигурируется само приложение.

* <a name="arch-package"><h3>Пакеты</h3></a>
  Приложение состоит из пакетов.
  Пакет это каталог, имеющий особый конфигурационный файл. Варианты названий конфигурационного файла:
  * `composer.json`
  * `lx-config.php`
  * `lx-config.yaml`
  * `lx-config/main.php`
  * `lx-config/main.yaml`<br>
  Наличие конфигурационного файла `composer.json` означает, что каталог является composer-пакетом.<br>
  Наличие конфигурационного файла с префиксом `lx` означает, что каталог является lx-пакетом.<br>
  Пакет может быть composer-пакетом и lx-пакетом одновременно (иметь оба конфигурационных файла).<br>
  В файле lx-конфигурации рекомендуется описывать правила автозагрузки (а не в `composer.json`), т.к. платформа имеет свой автозагрузчик, не противоречащий автозагрузчику композера, но имеющий расширенные возможности.<br>
  Файл `composer.json` может быть использован для описания зависимостей.<br>
  О прочих особенностях lx-конфигурации далее.<br>
  Пакеты могут располагаться в нескольких каталогах внутри приложения. В каких именно - определяется в конфигурации приложения. [Подробнее о конфигурации приложения](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/app-config.md)

* <a name="arch-service"><h3>Сервисы</h3></a>
  Сервис это пакет, умеющий отвечать на запросы.<br>
  Для этого оснащен набором инструментов:
  * [Роутеры уровня сервисов](#arch-service-router)
  * [Контроллеры](#arch-controller)
  * [Действия (экшены)](#arch-action)
  * [Плагины](#arch-plugin)

  Имеет специальное поле с настройками в lx-конфигурации. Пример конфигурации на `yaml`:
  ```yaml
  # Имя сервиса
  name: lx/lx-model

  # Правила автозагрузки
  autoload:
    psr-4:
      lx\devWizard\: ''

  # Поле с настройками сервиса - наличие именно этого поля превращает пакет в сервис
  service:
    # Если сервис представлен собственным классом, здесь указывается его имя
    class: lx\model\Service

    # Прочие настройки сервиса
    plugins: plugin
    models: model
    ...
  ```
  Имеет определенную инфраструктуру, описываемую с помощью lx-конфигурации.
  [Подробнее о конфигурации сервиса](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/service-config.md)

* <a name="arch-router"><h3>Роутер уровня приложения</h3></a>
  Приложение распределяет запросы по сервисам с помощью роутера. Он существует в приложении в единственном числе.<br>
  Настраивается роутер в конфигурации приложения. Пример:
  ```yaml
  ...
  # Варианты типов:
  # - map
  #   необходим параметр 'routes' - сама карта
  #   карта - ассоциативный массив:
  #     ключ - URL запроса (или регулярное выражение, если начинается с символа '~')
  #     значение - данные о запрашиваемом ресурсе
  # - class 
  #   необходим параметр 'name' - имя класса роутера
  #   роутер наследуется от [[lx\Router]]
  router:
    type: map
    routes:
      # Домашняя страница
      /: your/home-service

      # URL, ориентированный непосредственно на плагин сервиса,
      # причем работающий только для определенного режима приложения
      test-page: {service-plugin: 'your/some-service:some-plugin', on-mode: dev}
  ...
  ```
  ![Схема роутинга приложения](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/images/architecture-scheme.png)
  [Подробнее о роутинге](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/routing.md)

* <a name="arch-service-router"><h3>Роутеры уровня сервиса</h3></a>
  Управлением запросами внутри сервисов занимаются роутеры сервисов.<br>
  По аналогии с роутером приложения, роутер сервиса можно настроить с помощью файла lx-конфигурации сервиса, либо переопределить класс `lx\ServiceRouter`.<br>
  Пример настройки через файл lx-конфигурации:
  ```yaml
  name: lx/lx-model
  ...

  service:
    class: lx\model\Service

    # Настройки роутера сервиса
    router:
      type: map
      routes:
        # Направление запроса на контроллер
        # Будет возвращен результат вызова метода(экшена) контроллера [[run()]]
        some-route-1: ControllerClassName

        # Направление запроса на контроллер
        # Будет возвращен результат вызова метода(экшена) контроллера [[actionName()]]
        some-route-2: ControllerClassName::actionName

        # Направление запроса на экшен. Будет возвращен результат вызова метода экшена [[run()]]
        some-route-3: {action: ActionClassName}

        # Направление запроса на плагин. Будет возвращен результат рендеринга плагина
        some-route-4: {plugin: pluginName}
    ...
  ```
  ![Схема внутрисервисного роутинга](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/images/service-routing.png)

* <a name="arch-controller"><h3>Контроллеры</h3></a>
  Контроллер является таким элементом сервиса, который отвечает на запросы и может обрабатывать много разных URL.<br>
  Если в настройках роутера уровня сервиса для определенного URL указано только имя класса контроллера, для обработки запроса будет вызван метод `run()`.<br>
  Если в настройках роутера уровня сервиса для определенного URL указано имя класса контроллера и метод (н-р так: `ControllerClassName::actionName`), то для обработки запроса будет вызван указанный метод.

* <a name="arch-action"><h3>Действия (экшены)</h3></a>
  Действие (экшен) является таким элементом сервиса, который отвечает на какой-то один запрос.<br>
  Для обработки запроса будет вызван метод `run()`.

* <a name="arch-plugin"><h3>Плагины</h3></a>
  Плагин является элементом сервиса, представляющим собой совокупность логики, выполняющейся на клиенте, графического интерфейса, её обслуживающего и серверной части, представленной респондентами (AJAX-контроллеры, работающие в контексте конкретных плагинов). По своей идее напоминает SPA.
  
  Свойства плагина:
  * рендерится и загружается браузером однократно
  * выполняется без перезагрузки страницы
  * в структуре проекта имеет свою директорию с определенной инфраструктурой
  * имеет свой файл lx-конфигурации для настройки некоторых параметров и инфраструктуры
  * имеет свои ресурсы (JS-код, CSS-код, изображения и т.п.)
  * в коде своих сниппетов (JS-файлы представлений) плагин доступен в виде контекстной переменной `$Plugin`
  * в своем JS-коде плагин доступен в виде контекстной переменной `Plugin`
  * данные с сервера запрашивает при помощи AJAX-запросов
  * для формирования данных, отдаваемых сервером имеет свои инструменты ([респонденты](#arch-respondent))
  * любой плагин может загрузить любой другой плагин и поместить его в элемент на своей странице
  * рендеринг плагина можно инициировать с передачей параметров, в случае, если они предусмотрены
  
  Перечень элементов инфраструктуры плагина:
  * JS-код плагина. Основных файлов для исполнения два - один будет выполняться до разворачивания плагина (путь к файлу определяет ключ конфигурации `jsBootstrap`), другой после (путь к файлу определяет ключ конфигурации `jsMain`).
  * Респонденты. Классы, которые пишутся на PHP, представляют собой AJAX-контроллеры, отдают данные, запрашиваемые клиентской частью плагина (ключ конфигурации `respondents`).
  * Представление. Рендеринг плагина начинается с корневого сниппета, код которого описывается в файле, путь к которому определяет ключ конфигурации `rootSnippet`. В определенных ситуациях удобно обращаться к сниппетам по имени их файлов (или каталогов) относительно общего корневого каталога для сниппетов, перечень таких каталогов также можно задать в конфигурации (ключ `snippets`).
  * Изображения (ключ конфигурации `images`). Можно задать каталог, в котором будут лежать изображения плагина.
  * CSS-ресурсы (ключ конфигурации `css`). Можно задать каталог, в котором будут лежать css-файлы плагина. При загрузке плагина эти файлы будут использоваться автоматически.<br>
  Пример настройки элементов инфраструктуры плагина в lx-конфигурации:
  ```yaml
  # JS-код, который выполнится до разворачивания плагина, будет находиться
  # в файле 'frontend/_bootstrap.js' относительно корневого каталога плагина
  jsBootstrap: frontend/_bootstrap.js
  # JS-код, который выполнится после разворачивания плагина, будет находиться
  # в файле 'frontend/_main.js' относительно корневого каталога плагина
  jsMain: frontend/_main.js

  # Карта респондентов
  respondents:
    # Ключ - псевдоним респондента для клиентской стороны
    # Значение - имя класса респондента
    # (!)пространство имен указывается относительно пространства имен плагина
    Respondent: backend\Respondent

  # Корневым файлом графического интерфейса будет 'snippets/_root.js',
  # он содержит код корневого сниппета плагина
  rootSnippet: snippets/_root.js

  # Путь к директории с изображениями
  # Можно использовать алиасы приложения - тогда путь будет построен согласно алиасу
  # Можно начать с символа '/' - тогда путь будет считаться относительно корня сайта
  images: assets/images

  # Путь к директории с css-файлами
  css: assets/css
  ```
  [Подробнее о конфигурации плагина](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/plugin-config.md)

  Нижнее подчеркивание в названиях файлов - выбор автора платформы для обозначения особого статуса файлов (корневые файлы, точки входа для выполнения и т.п.), а также упрощения их визуального поиска в проводнике проекта при сортировке каталогов и файлов по алфавиту (нижнее подчеркивание находится между прописными и строчными символами). При желании все соглашения о путях меняются с помощью конфигурации.

* <a name="arch-snippet"><h3>Сниппеты</h3></a>
  Сниппеты это обособленные фрагменты графического интерфейса. Код сниппетов пишется в процедурном стиле (в противовес виджетам, код которых пишется в стиле ООП, см. ниже). Могут быть представлены либо отдельным js-файлом, либо каталогом, в котором должен присутствовать js-файл с представлением (в таком случае, имя js-файла должно соответствовать имени каталога сниппета, при этом возможно, но не обязательно предварение имени файла нижним подчеркиванием).<br>
  Варианты как может выглядеть путь к сниппету с именем `snippetName`:
  * path/to/snippet/snippetName.js
  * path/to/snippet/snippetName/snippetName.js
  * path/to/snippet/snippetName/\_snippetName.js<br>
  Таким образом, философия сниппетов подразумевает их использование в ситуациях, когда для фрагмента интерфейса не нужно применение ОО-приемов (инкапсуляция, наследование, полиморфизм), т.е. это часть интерфейса специфичная для данного участка приложения (опять же в противовес виджетам). Однако это не означает, что отсутствует механизм повторного использования кода сниппетов.

  Сниппет может иметь свой JS-код, выполняющийся на стороне клиента. Для этого в коде сниппета нужно определить функцию и передать ее в метод `Snipept.onload()`:
  ```js
  /**
   * @const lx.Application App
   * @const lx.Plugin Plugin
   * @const lx.Snippet Snippet
   * */

   Snippet.onload(()=>{
      console.log('This code has executed on the client side!');
   });
  ```

  При написании кода сниппета доступны три контекстные переменные:
  * App - объект приложения
  * Plugin - объект плагина, к которому относится сниппет
  * Snippet - объект самого сниппета. Имеет свойство `widget`, являющееся экземпляром класса `lx.Box`. Также имеет свойство `clientParams`, обычный JS-объект, который будет доступен и на стороне клиента.

  При написании JS-кода сниппета доступны две контекстные переменные:
  * Plugin - объект плагина, к которому относится сниппет
  * Snippet - объект самого сниппета. Имеет свойство `widget`, являющееся экземпляром класса `lx.Box`. Также имеет свойство `clientParams`, обычный JS-объект, в котором могут содержаться поля, определенные на стороне сервера.

  Сниппеты строятся из виджетов. Сниппеты могут встраивать в себя другие сниппеты. Пример:
  ```js
  // Подключаем JS-модули, содержащие код нужных виджетов
  #lx:use lx.Box;
  #lx:use lx.Button;
  #lx:use lx.ActiveBox;

  // Создадим виджет
  let menu = new lx.Box(menuConfig);

  // Виджет добавляется внутрь другого виджета
  button = menu.add(lx.Button, buttonConfig);

  // Добавим пару виджетов, чтобы вложить в них сниппеты
  let box1 = new lx.Box(config1);
  let box2 = new lx.Box(config2);

  // Вкладываем сниппет - в данном случае имя это путь относительно файла
  // описываемого в данный момент сниппета
  // Можно использовать алиасы приложения
  // Если путь начать с '/', то он считается относительно корня сайта
  box1.setSnippet('snippetName1');

  // Вкладываем еще один сниппет - указываем конфигурацию
  // @param path - тот же путь, что в предыдущем случае
  // @param renderParams - массив параметров, которые будут доступны в качестве переменных
  //                       в файле, описывающем вкладываемый сниппет
  // @param clientParams - массив параметров, которые будут доступны в коде сниппета
  //                       через свойство [[Snippet.clientParams]]
  box2.setSnippet({
    path: 'snippetName2',
    renderParams: {},
    clientParams: {},
  });

  // Добавление сниппета: snippetName - имя сниппета, config - конфигурация виджета,
  // в который срендерится сниппет
  let innerSnippet = Snippet.addSnippet(snippetName, config);

  // Добавление нескольких сниппетов
  Snippet.addSnippets({
    snippetName1: config1,
    snippetName2: config2,
  });

  // Добавление нескольких сниппетов-попапов - они будут срендерены в виджет lx.ActiveBox
  let newSnippetsArray = Snippet.addSnippets([
    {
      path: 'pathToSnippet1',
      widget: lx.ActiveBox,
      // ... конфигурирование виджета
      renderParams: {/*...*/},
      clientParams: {/*...*/}
    },
    {
      path: 'pathToSnippet2',
      widget: lx.ActiveBox,
      // ... конфигурирование виджета
      renderParams: {/*...*/},
      clientParams: {/*...*/}
    }
  ]);

  // Добавим сниппет из другого плагина
  Snippet.addSnippet({
    plugin:'lx/lx-tools:snippets',
    snippet:'confirmPopup'
  });
  ```

  При выполнении js-кода сниппета в браузере, доступен контекст выполнения родительского сниппета, но недоступны контексты выполнения вложенных сниппетов. Например, в сниппет `A` вложен сниппет `B`, в сниппет `B` вложен сниппет `C`: `A -> B -> C`. В сниппетах объявлены соответственно переменные `a`, `b` и `c`. Тогда в сниппете `A` будет доступна только переменная `a`. В сниппете `B` будут доступны переменные `a` и `b`. В сниппете `C` будут доступны переменные `a`, `b` и `c`.

  Путь к корневому сниппету плагина задается в lx-конфигурации плагина по ключу `rootSnippet`.

  Пути к каталогам, содержащим сниппеты можно определить в lx-конфигурации плагина по ключу `snippets`.

* <a name="arch-widget"><h3>Виджеты</h3></a>
  Виджеты это узкофункциональные фрагменты графического интерфейса. Код виджетов пишется в стиле ООП (в противовес сниппетам).<br>
  Механизм работы виджетов имеет существенные особенности:
  * Экземпляр виджета можно создать как на серверной стороне, так и на клиентской
  * Экземпляр виджета, созданный на серверной стороне, инициирует создание экземпляра на клиентской стороне
  * Код виджета может содержать фрагменты, компилируемые только для сервера, или только для клиента
  * Файл с кодом виджета может находиться в каталоге. Пример:
    * path/to/widget/MyWidget/MyWidget.js
    или:
    * path/to/widget/MyWidget/\_MyWidget.js
    Имя класса такого виджета должно соответствовать имени каталога `MyWidget`.
  * Рекомендуется определять код виджета как JS-модуль, чтобы его было удобно подключать в коде сниппетов. [Подробнее о JS-модулях](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/js-modules.md)
    Пример:
    ```js
    #lx:module nmsp.example.MyWidget

    #lx:use lx.Box;

    class MyWidget extends lx.Box #lx:namespace nmsp.example
    {
        // ... общий код

        #lx:server {
            // ... код для сервера
        }

        #lx:client {
            // ... код для клиента
        }
    }
    ```
  * Конструктор виджета принимает конфигурацию в виде ассоциативного массива. Для легкого поиска на стороне клиента виджета, созданного на серверной стороне, важным параметром конфигурации является `key`.
  * Экземпляр виджета на стороне сервера поддерживает создание динамических свойств. Эти свойства будут доступны у экземпляра на стороне клиента.
  Пример:
  Код на стороне сервера:
  ```js
  // Создаем виждет с ключом
  let button = new lx.Button({key: 'myButton'});

  // Добавим динамическое свойство
  button.testField = 'hello from server!';
  ```
  Код на стороне клиента:
  ```js
  // Получаем экземпляр виджета lx.Button по ключу
  // Оператор "->>" означает поиск виджета по ключу на любом уровне вложенности дерева виджетов
  const myButton = Plugin->>myButton;

  // Проверим динамическое свойство, в консоли увидим 'hello from server!'
  console.log(myButton.testField);
  ```
  Таким образом, философия виджетов подразумевает использование их для описания наиболее часто используемых, узкофункциональных и универсальных фрагментов графического интерфейса.

* <a name="arch-respondent"><h3>Респонденты</h3></a>
  Респонденты это функциональные элементы плагина. Фактически являются php классами. Представляют собой ajax-контроллеры, которые отдают данные клиентской части плагина.
  Пример респондента:
  * Определение в конфигурации плагина
    ```yaml
    respondents:
      Respondent: backend\Respondent
    ```
  * Код респондента (согласно приведенной конфигурации должен находиться в файле `backend/Respondent.php` относительно корня плагина)
    ```php
    <?php

    namespace path\to\plugin\backend;

    class Respondent extends \lx\Respondent
    {
      public function test()
      {
        return 'Hello from server';
      }
    }
    ```
  * Использование респондента в js-коде плагина
    ```js
    ^Respondent.test() : (result) => {
      // result содержит строку 'Hello from server'
      console.log(result);
    };
    ```


<a name="cli"><h2>CLI</h2></a>
Приложение поддерживает интерфейс командной строки.<br>
Чтобы его запустить нужно перейти в директорию `path\to\project\lx` и выполнить команду `php lx cli`.<br>
Команда `\h` (или `help`) отобразит список доступных команд.

Создадим свой сервис. Для этого введем команду `\cs` (или `create-service`).<br>
Нам предложат ввести имя сервиса. Введем что-то вроде `i-am-vendor/my-service`.<br>
Так как в конфигурации приложения указано несколько директорий для пакетов (и сервисов в частности), нам предложат выбрать нужную директорию. Выберем вторую (services) - вводим `2`.<br>
Готово!<br>
По указанному адресу можно проверить что именно создалось, сверить с описанной в этой документации инфраструктурой сервиса.

Теперь создадим в сервисе плагин. Для этого перейдем в сервис. Сделать это можно несколькими путями, например введем команду `\g i-am-vendor/my-service` (если назвали сервис по-своему - используйте свое название). Признаком того, что мы перешли в сервис является смена `lx-cli<app>` на `lx-cli<service:i-am-vendor/my-service>`. Другой способ попасть в сервис - по индексу. Узнать индекс можно командой `\sl` - будет отображен список имеющихся сервисов, порядковый номер сервиса и есть его индекс. Например, если индекс 2, то перейти к сервису можно командой `\g -i=2`.<br>
Наконец создаем плагин командой `\cp`. Нас снова попросят ввести имя, вводим, например, `myPlugin`.<br>
Это все!<br>
Плагин создан, по указанному адресу можно проверить что именно создалось, сверить с описанной в этой документации инфраструктурой плагина.

Теперь можно узнать подробнее как разрабатывать свое приложение по [ссылке](https://github.com/epicoon/lx-doc-articles/blob/master/ru/app-dev/expl1/main.md).
